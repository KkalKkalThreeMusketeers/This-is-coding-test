# 1 주차
<br>

## 교재 문제

<br>

### 거스름돈

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class change {
	
	public static void main(String[] args) throws IOException {
		
		int[] coins = new int[]{500, 100, 50, 10};
//		int[] coins = {500, 100, 50, 10};
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int money = Integer.parseInt(br.readLine());
		
		int cnt = 0;
		
		for(int i=0; i<4; i++) {
			cnt += money/coins[i];
			money = money%coins[i];
		}
		
		System.out.println(cnt);
	}
}
```

<br>

#### [해결방안]

- 돈을 큰수부터 차례대로 나눠준다. 
(500원->100원->50원->10원)으로 나눈 몫을 cnt에 더해주고, 남은 돈은 (500원->100원->50원->10원)부터 나눈 나머지이다.

<br>

#### [어려웠던 부분]

- 없음
---


### 큰 수의 법칙

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class big_number_rule {

	public static void main(String[] args) throws IOException {

		//N, M, K 입력받기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());
		int K = Integer.parseInt(st.nextToken());

		//N개의 자연수 입력받기
		int[] array = new int[N];
		st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			array[i] = Integer.parseInt(st.nextToken());
		}

		//첫번째로 큰수, 두번째로 큰수 찾기
		int firstBig = 0;
		int secondBig = 0;
		for(int i=0; i<N; i++) {
			if(array[i] >= firstBig) {
				secondBig = firstBig;
				firstBig = array[i];
			} else {
				if(array[i] > secondBig) {
					secondBig = array[i];
				}
			}
		}

		//첫번째로 큰수는 K번 더하고 두번째로 큰수는 1번 더해서 M이 나오도록 해야함
		//-> M==0일때 break
		int result = 0;
		while(M>0) {
			for(int i=0; i<K; i++) {
				result += firstBig;
				M--;

				if(M==0)
					break;

			}
			if(M==0)
				break;

			result += secondBig;
			M--;
			if(M==0)
				break;

		}

		System.out.println(result);
	}

}
```

<br>

#### [해결방안]

- 먼저, 첫번째로 큰수와 두번째로 큰수를 찾는다.
첫번째로 큰수(A)를 K번 더하고 두번째로 큰수(B)를 1번 더하는 것을 반복해서 더한 숫자가 M이 되면 된다.
ex) K=3, M=8 A+A+A+B+A+A+A+B => (총 M개)
그래서 한번씩 더해줄 때마다 M을 하나씩 줄어들게 하고 M이 0일때 반복문을 빠져나오게 한다.

<br>

#### [어려웠던 부분]

- 첫번째로 큰수와 두번째로 큰수 : 정렬해서 찾기
가장 큰수가 등장하는 횟수를 구하는 방법 : (M/(K+1)) * K + M%(K+1)
M/(K+1)만큼 반복하는데 그 중에 K번 가장 큰수를 더한다. 나누어떨어지지 않는경우, 그 나머지 모두가 가장 큰수를 더하는 것이므로 나머지를 더해준다.  
---

### 숫자 카드 게임

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class number_card_game {

	public static void main(String[] args) throws IOException {

		//N, M 입력받기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());

		//이차원 배열 입력받기
		int[][] array = new int[N][M];

		for(int i=0; i<N; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j=0; j<M; j++) {
				array[i][j] = Integer.parseInt(st.nextToken());
			}
		}

		//각 행별로 정렬하기
		//정렬하여 각 행별로 첫번째 열은 가장 작은 값
		for(int i=0; i<N; i++) {
			Arrays.sort(array[i]);
		}

		//첫번째 열을 비교하여 큰 값만 가져온다
		int result = 0;
		for(int i=0; i<N; i++) {
			if(array[i][0] > result) {
				result = array[i][0];
			}
		}
		System.out.println(result);

	}

}
```

<br>

#### [해결방안]

- 먼저, 각 행별로 정렬한다. 
정렬하면 가장 작은 수가 제일 첫번째로 오게 되므로 첫번째 열만 비교해서 가장 큰 값을 찾는다. 

<br>

#### [어려웠던 부분]

- 입력받을 때부터 현재 줄(행)에서 가장 작은 수를 Math.min()으로 찾고,
현재 행에서 다음 행으로 넘어가기 전에 Math.max()으로 가장 작은 수들을 찾은것 중에서 가장 큰수를 찾는다. 
---


### 1이 될 때까지

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class until_it_becomes_one {

	public static void main(String[] args) throws IOException {

		//N, K 입력받기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int K = Integer.parseInt(st.nextToken());

		int count = 0;

		while(N>1) {
			//N이 K로 나누어 떨어질때 N을 K로 나누고
			//안 될때 N에서 1을 뺀다
			if(N%K==0) {
				N = N/K;
				count++;
			} else {
				N -= 1;
				count++;
			}

			//N이 1이 될때 종료한다.
			if(N==1) {
				break;
			}
		}
		System.out.println(count);
	}

}
```

<br>

#### [해결방안]

- N을 K로 나누는 것이 N을 K로 빼는 것보다 더 빨리 숫자를 작게 만들 수 있다. 
그래서 N을 K로 나누어 떨어지면 나누고, 그렇지 않으면 1을 뺀다.
각각 계산을 할 떄마다 count를 1씩 더해주고, N이 1이 되면 종료되어 반복문을 빠져나오게 한다.

<br>

#### [어려웠던 부분]

- 책 p.102 3-6.py 예제가 이해되지 않는다. (코드 돌아가는 것도 어떻게 동작하는지 모르겠음)
---

<br><br>

## OJ 문제

<br>

### [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)

#### [코드]


```java
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860)

#### [코드]


```java
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [큰 수 만들기](https://programmers.co.kr/learn/courses/30/lessons/42883)

#### [코드]


```java
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)

#### [코드]


```java
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---
