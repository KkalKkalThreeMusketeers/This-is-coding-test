# 1 주차
<br>

## 교재 문제

<br>

### 거스름돈

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class change {
	
	public static void main(String[] args) throws IOException {
		
		int[] coins = new int[]{500, 100, 50, 10};
//		int[] coins = {500, 100, 50, 10};
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int money = Integer.parseInt(br.readLine());
		
		int cnt = 0;
		
		for(int i=0; i<4; i++) {
			cnt += money/coins[i];
			money = money%coins[i];
		}
		
		System.out.println(cnt);
	}
}
```

<br>

#### [해결방안]

- 돈을 큰수부터 차례대로 나눠준다.  
(500원->100원->50원->10원)으로 나눈 몫을 cnt에 더해주고, 남은 돈은 (500원->100원->50원->10원)부터 나눈 나머지이다.

<br>

#### [어려웠던 부분]

- 없음  

---


### 큰 수의 법칙

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class big_number_rule {

	public static void main(String[] args) throws IOException {

		//N, M, K 입력받기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());
		int K = Integer.parseInt(st.nextToken());

		//N개의 자연수 입력받기
		int[] array = new int[N];
		st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			array[i] = Integer.parseInt(st.nextToken());
		}

		//첫번째로 큰수, 두번째로 큰수 찾기
		int firstBig = 0;
		int secondBig = 0;
		for(int i=0; i<N; i++) {
			if(array[i] >= firstBig) {
				secondBig = firstBig;
				firstBig = array[i];
			} else {
				if(array[i] > secondBig) {
					secondBig = array[i];
				}
			}
		}

		//첫번째로 큰수는 K번 더하고 두번째로 큰수는 1번 더해서 M이 나오도록 해야함
		//-> M==0일때 break
		int result = 0;
		while(M>0) {
			for(int i=0; i<K; i++) {
				result += firstBig;
				M--;

				if(M==0)
					break;

			}
			if(M==0)
				break;

			result += secondBig;
			M--;
			if(M==0)
				break;

		}

		System.out.println(result);
	}

}
```

<br>

#### [해결방안]

- 먼저, 첫번째로 큰수와 두번째로 큰수를 찾는다.  
첫번째로 큰수(A)를 K번 더하고 두번째로 큰수(B)를 1번 더하는 것을 반복해서 더한 숫자가 M이 되면 된다.  
ex) K=3, M=8 일때, A+A+A + B + A+A+A + B => (총 M개)  
그래서 한번씩 더해줄 때마다 M을 하나씩 줄어들게 하고 M이 0일때 반복문을 빠져나오게 한다.  

<br>

#### [어려웠던 부분]

- 첫번째로 큰수와 두번째로 큰수 : 정렬해서 찾기  
가장 큰수가 등장하는 횟수를 구하는 방법 : (M/(K+1)) * K + M%(K+1)  
M/(K+1)만큼 반복하는데 그 중에 K번 가장 큰수를 더한다.  
나누어떨어지지 않는경우, 그 나머지 모두가 가장 큰수를 더하는 것이므로 나머지를 더해준다.  

---

### 숫자 카드 게임

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class number_card_game {

	public static void main(String[] args) throws IOException {

		//N, M 입력받기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());

		//이차원 배열 입력받기
		int[][] array = new int[N][M];

		for(int i=0; i<N; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j=0; j<M; j++) {
				array[i][j] = Integer.parseInt(st.nextToken());
			}
		}

		//각 행별로 정렬하기
		//정렬하여 각 행별로 첫번째 열은 가장 작은 값
		for(int i=0; i<N; i++) {
			Arrays.sort(array[i]);
		}

		//첫번째 열을 비교하여 큰 값만 가져온다
		int result = 0;
		for(int i=0; i<N; i++) {
			if(array[i][0] > result) {
				result = array[i][0];
			}
		}
		System.out.println(result);

	}

}
```

<br>

#### [해결방안]

- 먼저, 각 행별로 정렬한다.  
정렬하면 가장 작은 수가 제일 첫번째로 오게 되므로 첫번째 열만 비교해서 가장 큰 값을 찾는다. 

<br>

#### [어려웠던 부분]

- 입력받을 때부터 현재 줄(행)에서 가장 작은 수를 Math.min()으로 찾고,  
현재 행에서 다음 행으로 넘어가기 전에 Math.max()으로 가장 작은 수들을 찾은것 중에서 가장 큰수를 찾는다.  

---


### 1이 될 때까지

#### [코드]

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class until_it_becomes_one {

	public static void main(String[] args) throws IOException {

		//N, K 입력받기
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken());
		int K = Integer.parseInt(st.nextToken());

		int count = 0;

		while(N>1) {
			//N이 K로 나누어 떨어질때 N을 K로 나누고
			//안 될때 N에서 1을 뺀다
			if(N%K==0) {
				N = N/K;
				count++;
			} else {
				N -= 1;
				count++;
			}

			//N이 1이 될때 종료한다.
			if(N==1) {
				break;
			}
		}
		System.out.println(count);
	}

}
```

<br>

#### [해결방안]

- N을 K로 나누는 것이 N을 K로 빼는 것보다 더 빨리 숫자를 작게 만들 수 있다.  
그래서 N을 K로 나누어 떨어지면 나누고, 그렇지 않으면 1을 뺀다.  
각각 계산을 할 떄마다 count를 1씩 더해주고, N이 1이 되면 종료되어 반복문을 빠져나오게 한다.  

<br>

#### [어려웠던 부분]

- 책 p.102 3-6.py 예제가 이해되지 않는다. (코드 돌아가는 것도 어떻게 동작하는지 모르겠다)  

---

<br><br>

## OJ 문제

<br>

### [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)

#### [코드]


```java
class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int answer = 0;
        
        int[] student = new int[n+1];
        
        for(int i=1; i<n+1; i++) {
            student[i]++;
        }
        
        //잃어버린 학생들의 체육복 수를 -1함
        for(int i=0; i<lost.length; i++) {
            student[lost[i]]--; 
        }
        
        //여벌옷을 갖고 있는 학생들의 체육복 수를 +1함
        for(int j=0; j<reserve.length; j++) {
            student[reserve[j]]++;
        }
        
        for(int i=1; i<n+1; i++) {
            //먼저, 체육복이 없는 학생은 자기보다 아래인 사람한테 옷을 빌린다.
            if(student[i]==0 && student[i-1]>1) {
                student[i]++;
                student[i-1]--;
                continue; //빌린사람은 또 빌리지 않기 하기 위해
            }
            
            if(i<n){ //n+1(제일 체격좋은 학생)은 자기보다 위에 있는 사람이 없다. 즉, 위인 사람한테 빌릴수 없음 
                //자기보다 아래인 사람은 없는데 위인 사람한테 옷을 빌릴 수 있을 때
                if(student[i]==0 && student[i+1]>1) {
                    student[i]++;
                    student[i+1]--;
                }
            }
                                  
        }
        
        for(int i=1; i<student.length; i++) {
            //System.out.println(student[i]);
            if(student[i]>0) {
                answer++;
            }
        }
        
        return answer;
    }
}
```

<br>

#### [해결방안]

- 학생수+1(1번 학생이 1번 배열에 들어갈 수 있게끔 하기 위해)만큼 배열을 만들어 모두 하나씩 옷을 가져왔으니 1씩 배열에 넣는다.
- 옷을 잃어버린 학생들은 -1을 하고, 여벌 옷을 가져온 학생들은 +1을 한다.
- 배열 안에 0인 학생은 먼저 아래인 학생이 여벌이 있으면 아래인 학생에게 옷을 빌리고, 아래인 사람에게 없으면 위인 사람한테 빌린다.
- 제일 위인 사람은 위인 사람이 없으므로 위인 사람한테 빌릴 수 없다.

<br>

#### [어려웠던 부분]

- 자기 옷도 잃어버리고 여벌 옷도 가져온 학생을 따로 구해야하는 줄 알았는데, 따로 생각하지 않아도 된다는 점이 어려웠다
- 아래인 학생한테도 빌리고 위인 학생한테도 빌릴 수 있으니 아래인 학생한테 먼저 빌리는 기준을 생각해야 한다는 점이 어려웠다
---

### [조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860)

#### [코드]


```java
class Solution {
    public int solution(String name) {
        int answer = 0;
        
        //상하조작
        //B~M은 다음 알파벳으로 이동해야하고,
        //N은 다음 알파벳으로도 13번 이동, 이전 알파벳으로도 13번 이동이라 상관X
        //O~Z는 이전 알파벳으로 이동해야한다.
        for(int i=0; i<name.length(); i++) {
            
            //B~N 부분 (아스키코드 65:A, 79:O)
            if(name.charAt(i) >= 65 && name.charAt(i) < 79) {
                answer += name.charAt(i) - 65;
            } else { //O~Z 부분 (아스키코드 90:Z)
                answer += 91 - name.charAt(i);
            }
            
            //answer = Math.min(name.charAt(i)-'A','Z'-name.charAt(i)+1);
            
        }
        
        //좌우조작
        int i = 1;
        //원래 : 오른쪽으로 한번에 갈때가 최솟값
        int move = name.length() - 1;
        while(i<name.length()) {
            if(name.charAt(i)=='A') { //A일때
                int R = i-1; //오른쪽으로 이동개수
                i++;
                while(i<name.length() && name.charAt(i)=='A') { //그 다음에도 A일 때
                    i++;
                }
                int L = name.length()-i; //왼쪽으로 이동개수

                //최솟값 찾기
                move = Math.min(move, 2*R+L); //2*R+L : 오른쪽으로 갔다가 다시 왼쪽으로 갈 때
                move = Math.min(move, 2*L+R); //2*L+R : 왼쪽으로 갔다가 다시 오른쪽으로 갈 때
            }
            else {
                i++;
            }
        }
        
        answer = answer + move;
        
        return answer;
    }
}
```

<br>

#### [해결방안]

- 상하조작 : B~M은 A에서 다음으로 이동하는 것이 좋고, O~Z는 A에서 이전으로(거꾸로) 이동하는 것이 좋다. N은 어디로 이동해도 13번 이동이라 상관없다.
- A~N은 A를 뺀 숫자만큼, O~Z는 Z에서 뺀 숫자에서 1을 더한큼 이동하는 것이다. (Math.min으로 할 수 있다)  
- 좌우조작 : 연속된 A만큼 R과 L을 지정해준다. (R은 처음부터 A가 나오기전까지, L은 끝에서부터 A가 나오기 전까지)
- 원래 오른쪽으로만 조작한다면 전체길이-1이다.
- 오른쪽으로 갔다가 다시 왼쪽으로 가서 조작하는 방법과 왼쪽으로 갔다가 다시 오른쪽으로 가서 조작하는 방법과 전체길이-1 중에서 가장 작은 값이 나오는 것이 좌우조작의 최솟값이다.
- answer = 상하조작 + 좌우초작;

<br>

#### [어려웠던 부분]

- 좌우로 커서를 이동하는 것이 어려웠다
- 연속된 A를 찾는 것이 어려웠다
---

### [큰 수 만들기](https://programmers.co.kr/learn/courses/30/lessons/42883)

#### [코드]


```java
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)

#### [코드]


```java
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---
