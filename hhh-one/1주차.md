# 1 주차 (3장.그리디)
<br>

## 교재 문제

<br>

### 거스름돈

#### [코드]

```python
min = 0 #동전의 최소 개수

N = int(input()) #거스름돈
min += N // 500
N = N % 500
min += N // 100
N = N % 100
min += N // 50
N = N % 50
min += N // 10
N = N % 10

print(min)
```

<br>

#### [해결방안]

- 500원, 100원, 50원, 10원 순으로 거슬러야 동전을 최소한으로 쓴다.
- min은 각 동전을 단위로 나눈 몫을 더해주고, N은 단위로 나눈 나머지로 작성해주었다.

<br>

#### [알게된 부분]

- 큰 단위가 항상 작은 단위의 배수여야 그리디 알고리즘으로 해결할 수 있다.
---


### 큰 수의 법칙

#### [코드]

```python
#n: 배열의 크기 m:숫자가 더해지는 횟수 k:연속 가능 수
n, m, k = map(int, input().split()) #공백으로 구분하여 입력받기
array = list(map(int, input().split()))
largeNum = 0

array.sort()
for i in range(m):
    if(i == 0):#i = 0일 때는 i % k == 0이기 때문이다
        largeNum += array[n - 1]
        continue
    if(i % k == 0):
        largeNum += array[n - 2]
    else:
        largeNum += array[n - 1]

print(largeNum)
```

<br>

#### [해결방안]

- 먼저 배열을 sort()를 이용해 정렬하였다.
- i = 0부터 m-1까지 반복하며, i가 k번의 배수일 때 2번째로 큰 수를 더해줘야 하므로 나머지를 이용하였다.
- 다만 i = 0일 때는 나머지가 0이지만 가장 큰 수를 더해야 하므로 따로 조건문으로 빼주었다.

<br>

#### [어려웠던 부분]

- array를 받을 때 n만큼의 크기를 가진 배열을 받아야되는데 어떻게 할지 모르겠다.

<br>

#### [알게된 부분]
- 파이썬 공부를 오래 안해서 map함수를 까먹었었는데, 문제를 풀며 상기시키는 계기가 되었다.
---

### 숫자 카드 게임

#### [코드]

```python
# n행 m열
n, m = map(int, input().split())
result = list() #각 행의 가장 작은 수

for i in range(n):
    card = list(map(int, input().split()))
    card.sort()
    result.append(card[0])
print(max(result))
```

<br>

#### [해결방안]

- 행의 수만큼 반복해 행의 가장 작은 수를 알아낸다.
- 각 행을 정렬해서 가장 작은 수인 인덱스 0번을 result에 넣는다.
- result 리스트에서 가장 큰 값을 출력해준다.

<br>

#### [알게된 부분]

- 정렬을 하지 않고 min()함수를 이용해 가장 작은 값을 찾아낸다.
---


### 1이 될 때까지

#### [코드]

```python
n, k = map(int, input().split())
min = 0 #최소 횟수

while(True):
    if(n == 1):
        break
    if(n % k == 0):
        n = n / k
        min += 1
    else:
        n -= 1
        min += 1

print(min)
```

<br>

#### [해결방안]

- 무한 반복문을 이용해 n이 1이 될때까지 반복하였다.
- n이 k에 나누어 떨어질 때는 n을 k로 나누고, n이 k에 나누어 떨어지지 않으면 1을 빼주었다.

<br>

#### [어려웠던 부분]

- 코드 예시를 생각하는데 시간이 걸렸다.
---

<br><br>

## OJ 문제

<br>

### [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)

#### [코드]


```python
def solution(n, lost, reserve):
    answer = 0

    answer += n - len(lost)  #체육복을 가지고 있는 학생들
    
    #잃어버렸지만 여분의 체육복이 있는 학생들
    for l in lost:
        for r in reserve:
            if(l == r):
                reserve.remove(r)
                lost.remove(l)
                answer += 1

    for l in lost:
        for r in reserve:
            if(l == r - 1 or l == r + 1): #lost 기준 앞 뒤일 때
                answer += 1
                reserve.remove(r)
                break #앞 뒤 중복해서 빌리는 경우를 제외하기 위함
    return answer
```

<br>

#### [해결방안]

- 먼저 잃어버리지 않은 학생들을 더해준다.
- '여벌의 체육복을 가져온 학생이 도난당할 수 있다'는 조건으로 lost와 reserve에 둘다 포함되어 있는 학생들은 양쪽에서 제외시켜준다.
- lost 앞뒤 번호가 여분의 체육복이 있는지 반복해서 알아낸다.

<br>

#### [어려웠던 부분]

- 사실 85점이다. 어디서 틀렸는지 모르겠다
- 처음 조건을 확인하지 못하고 여벌의 체육복을 가져온 학생이 도난당하는 경우를 생각하지 않았다.
---

### [조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860)

#### [코드]


```python
def solution(name):
    answer = 0
    answer = len(name) - 1 #한 방향일 때
    
    #좌우
    i = 1
    while i < len(name):
        if name[i] == "A":
            R = i - 1
            i += 1
            while i < len(name) and name[i] == "A":
                i += 1
            L = len(name) - i
            answer = min([answer, 2 * R + L, 2 * L + R])
        else:
            i += 1
            
    #상하
    for i in name:
        U = ord(i) - ord("A")
        D = ord("Z") - ord(i)
        answer += min([U, D + 1])

    return answer
```

<br>

#### [해결방안]

- < [블로그](https://blog.naver.com/idmanddang/222753312957)를 참고했다.>
- 상하와 좌우가 독립적이므로 따로 생각을 한다.
- <좌우>
- DAABC라고 예를 들면, AA를 기준으로 AA의 오른쪽 B까지 가려면 좌로 2칸, AA의 왼쪽 D는 첫 커서이기 때문에 우로 0칸 이동해야한다.
- BCAARFQ라고 예를 들면, AA를 기준으로 AA의 오른쪽 R까지 가려면 좌로 3칸, AA의 왼쪽 C로 가려면 우로 1칸 이동해야한다.
- 한 방향(역방향 또는 정방향), 2R + L, 2L + R의 최솟값을 비교한다.
- <상하>
- 한 글자씩 비교한다.
- 위로 가는 방법의 개수와 아래로 가는 방법의 개수를 ord() 함수를 이용해 비교한다.
- 더 적은 것을 answer에 더해준다.

<br>

#### [어려웠던 부분]

- 중간에 A가 연속되어있으면 역방향, 순방향도 아닌 왼쪽, 오른쪽을 둘 다 이용하는 방식을 생각해야 하므로 어려웠다.

<br>

#### [알게된 부분]

- ord("글자") 함수는 그 글자의 아스키코드를 반환해준다.
- abs(숫자) 함수는 그 숫자의 절댓값을 반환해준다.
---

### [큰 수 만들기](https://programmers.co.kr/learn/courses/30/lessons/42883)

#### [코드]


```python
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)

#### [코드]


```python
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---