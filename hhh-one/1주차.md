# 1 주차 (3장.그리디)
<br>

## 교재 문제

<br>

### 거스름돈

#### [코드]

```python
min = 0 #동전의 최소 개수

N = int(input()) #거스름돈
min += N // 500
N = N % 500
min += N // 100
N = N % 100
min += N // 50
N = N % 50
min += N // 10
N = N % 10

print(min)
```

<br>

#### [해결방안]

- 500원, 100원, 50원, 10원 순으로 거슬러야 동전을 최소한으로 쓴다.
- min은 각 동전을 단위로 나눈 몫을 더해주고, N은 단위로 나눈 나머지로 작성해주었다.

<br>

#### [알게된 부분]

- 큰 단위가 항상 작은 단위의 배수여야 그리디 알고리즘으로 해결할 수 있다.
---


### 큰 수의 법칙

#### [코드]

```python
#n: 배열의 크기 m:숫자가 더해지는 횟수 k:연속 가능 수
n, m, k = map(int, input().split()) #공백으로 구분하여 입력받기
array = list(map(int, input().split()))
largeNum = 0

array.sort()
for i in range(m):
    if(i == 0):#i = 0일 때는 i % k == 0이기 때문이다
        largeNum += array[n - 1]
        continue
    if(i % k == 0):
        largeNum += array[n - 2]
    else:
        largeNum += array[n - 1]

print(largeNum)
```

<br>

#### [해결방안]

- 먼저 배열을 sort()를 이용해 정렬하였다.
- i = 0부터 m-1까지 반복하며, i가 k번의 배수일 때 2번째로 큰 수를 더해줘야 하므로 나머지를 이용하였다.
- 다만 i = 0일 때는 나머지가 0이지만 가장 큰 수를 더해야 하므로 따로 조건문으로 빼주었다.

<br>

#### [어려웠던 부분]

- array를 받을 때 n만큼의 크기를 가진 배열을 받아야되는데 어떻게 할지 모르겠다.

<br>

#### [알게된 부분]
- 파이썬 공부를 오래 안해서 map함수를 까먹었었는데, 문제를 풀며 상기시키는 계기가 되었다.
---

### 숫자 카드 게임

#### [코드]

```python
# n행 m열
n, m = map(int, input().split())
result = list() #각 행의 가장 작은 수

for i in range(n):
    card = list(map(int, input().split()))
    card.sort()
    result.append(card[0])
print(max(result))
```

<br>

#### [해결방안]

- 행의 수만큼 반복해 행의 가장 작은 수를 알아낸다.
- 각 행을 정렬해서 가장 작은 수인 인덱스 0번을 result에 넣는다.
- result 리스트에서 가장 큰 값을 출력해준다.

<br>

#### [알게된 부분]

- 정렬을 하지 않고 min()함수를 이용해 가장 작은 값을 찾아낸다.
---


### 1이 될 때까지

#### [코드]

```python
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

<br><br>

## OJ 문제

<br>

### [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862)

#### [코드]


```python
def solution(n, lost, reserve):
    answer = 0

    answer += n - len(lost)  #체육복을 가지고 있는 학생들
    
    #잃어버렸지만 여분의 체육복이 있는 학생들
    for l in lost:
        for r in reserve:
            if(l == r):
                reserve.remove(r)
                lost.remove(l)
                answer += 1

    for l in lost:
        for r in reserve:
            if(l == r - 1 or l == r + 1): #lost 기준 앞 뒤일 때
                answer += 1
                reserve.remove(r)
                break #앞 뒤 중복해서 빌리는 경우를 제외하기 위함
    return answer
```

<br>

#### [해결방안]

- 먼저 잃어버리지 않은 학생들을 더해준다.
- '여벌의 체육복을 가져온 학생이 도난당할 수 있다'는 조건으로 lost와 reserve에 둘다 포함되어 있는 학생들은 양쪽에서 제외시켜준다.
- lost 앞뒤 번호가 여분의 체육복이 있는지 반복해서 알아낸다.

<br>

#### [어려웠던 부분]

- 사실 85점이다. 어디서 틀렸는지 모르겠다
- 처음 조건을 확인하지 못하고 여벌의 체육복을 가져온 학생이 도난당하는 경우를 생각하지 않았다.
---

### [조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860)

#### [코드]


```python
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [큰 수 만들기](https://programmers.co.kr/learn/courses/30/lessons/42883)

#### [코드]


```python
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---

### [구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)

#### [코드]


```python
코드 작성란
```

<br>

#### [해결방안]

- 작성란

<br>

#### [어려웠던 부분]

- 작성란
---